/**
 * Copyright (C) 2020 IKOA Business Opportunity
 * All Rights Reserved
 * Author: Reinier Millo SÃ¡nchez <reinier.millo88@gmail.com>
 *
 * This file is part of the JobSity Challenge.
 * It can't be copied and/or distributed without the express
 * permission of the author.
 */
import { Router, Request, Response, NextFunction } from 'express';
import { AuthenticationCtrl } from '@/middlewares/authentication.middleware';
import { ResponseHandler } from '@/vendor/ikoabo/middlewares/response.middleware';
import { Objects } from '@/vendor/ikoabo/utils/objects.util';
import { AccountCtrl } from '@/controllers/accounts.controller';
import { TokenCtrl } from '@/controllers/tokens.controller';
import { TokenDocument } from '@/models/tokens.model';
import { Validator } from '@/vendor/ikoabo/middlewares/validator.middleware';
import { AccountRegisterValidation, AccountLoginValidation } from '@/models/accounts.joi';
import { ACCOUNT_TYPE } from '@/models/accounts.enum';
import { Token } from '@/vendor/ikoabo/utils/token.util';
import { AccountDocument } from '@/models/accounts.model';

/* Create router object */
const router = Router();

router.post('/register',
  Validator.joi(AccountRegisterValidation),
  (req: any, res: Response, next: NextFunction) => {
    /* Check for the type of account */
    if (Objects.get(req, 'body.type', ACCOUNT_TYPE.AT_USER) === ACCOUNT_TYPE.AT_USER) {
      /* User account must be registered by a service */
      return AuthenticationCtrl.doAuthenticate(['service'])(req, res, next);
    } else {
      /* Service or bot account must be registered by admin user */
      return AuthenticationCtrl.doAuthenticate(['user', 'admin'])(req, res, next);
    }
  },
  (req: any, res: Response, next: NextFunction) => {
    /* Get the given password and if its empty or null generate random password, preferably used in service and bot registration */
    let password: string = Objects.get(req, 'body.password', Token.longToken);
    if (password.length === 0) {
      password = Token.longToken;
    }

    /* Register the new user account */
    AccountCtrl.create({
      name: Objects.get(req, 'body.name'),
      type: Objects.get(req, 'body.type'),
      email: Objects.get(req, 'body.email'),
      password: password,
      about: Objects.get(req, 'body.about'),
    }).then((account: AccountDocument) => {
      /* Set the response information */
      res.locals['response'] = {
        email: Objects.get(req, 'body.email'),
      };

      /* Check if the password was autogenerated to attach to the response */
      if (Objects.get(req, 'body.password', '').toString().length === 0) {
        res.locals['response'].password = password;
      }

      next();
    }).catch(next);
  },
  ResponseHandler.success,
  ResponseHandler.error
);

router.post('/login',
  Validator.joi(AccountLoginValidation),
  (req: any, res: Response, next: NextFunction) => {
    AccountCtrl.fetch(null, { email: Objects.get(req, 'body.email') })
      .then((account: AccountDocument) => {
        /* Set the account to be used in next middleware */
        res.locals['account'] = account;

        /* Inspired in OAuth2, user can do login only from an authenticated service */
        if (account.type === ACCOUNT_TYPE.AT_USER) {
          return AuthenticationCtrl.doAuthenticate(['service'])(req, res, next);
        }

        /* Services and bots can authenticate directly */
        next();
      }).catch(next);
  },
  (req: any, res: Response, next: NextFunction) => {
    /* Validate the given password against the account stored password */
    res.locals['account'].validPassword(Objects.get(req, 'body.password'))
      .then(() => {
        /* Generate new access token to the validated account */
        TokenCtrl.create({
          token: Token.longToken,
          account: Objects.get(res, 'locals.account.id')
        }).then((token: TokenDocument) => {
          /* Set the response information */
          res.locals['response'] = {
            user: Objects.get(res, 'locals.account.id'),
            type: Objects.get(res, 'locals.account.type'),
            name: Objects.get(res, 'locals.account.name'),
            roles: res['locals'].account.getRoles(),
            token: token.token
          };
          next();
        }).catch(next);
      }).catch(next);
  },
  ResponseHandler.success,
  ResponseHandler.error
);

router.post('/logout',
  AuthenticationCtrl.doAuthenticate(),
  (req: any, res: Response, next: NextFunction) => {
    /* Delete the current used access token */
    TokenCtrl.delete(Objects.get(res, 'locals.token.id'))
      .then((token: TokenDocument) => {
        /* Set the response information */
        res.locals['response'] = {
          user: token.account,
        };
        next();
      }).catch(next);
  },
  ResponseHandler.success,
  ResponseHandler.error
);

router.get('/validate',
  AuthenticationCtrl.doAuthenticate(),
  (_req: any, res: Response, next: NextFunction) => {
    /* Set the response information from authentication */
    res.locals['response'] = {
      user: Objects.get(res, 'locals.token.account.id'),
      type: Objects.get(res, 'locals.token.account.type'),
      name: Objects.get(res, 'locals.token.account.name'),
      roles: res['locals'].token.account.getRoles()
    };
    next();
  },
  ResponseHandler.success,
  ResponseHandler.error
);

export default router;
